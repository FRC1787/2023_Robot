// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.subsystems.elevator;

import frc.robot.Constants;
import edu.wpi.first.math.MathUtil;
import edu.wpi.first.math.controller.ElevatorFeedforward;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.trajectory.TrapezoidProfile;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.revrobotics.CANSparkMax;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.CANSparkMax.SoftLimitDirection;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

public class Elevator extends SubsystemBase {
  /** Creates a new Drivetrain. */
  private CANSparkMax elevatorMotor;

  private RelativeEncoder encoder;
  private DigitalInput lowerLimitSwitch;

  // This PID controller is used to follow the trapezoidal motion profile generated by the MoveElevatorToPostion command.
  private PIDController velocityController;
  private ElevatorFeedforward feedforward;
  private TrapezoidProfile trapezoidProfile;
  private Timer timer;
  public boolean isMovingToTarget;
  private double targetPositionMeters;

  public double desiredVelocity;
  private boolean hasBeenHomed;

  public Elevator() {
    elevatorMotor = new CANSparkMax(
        Constants.ElevatorGrabber.elevatorMotorID,
        MotorType.kBrushless);

    // encoder = elevatorMotor.getAlternateEncoder(8192);
    // encoder.setPositionConversionFactor(1);
    // encoder.setVelocityConversionFactor(1);

    encoder = elevatorMotor.getEncoder();
    configureMotors();
  

    // SysId recommends an depth of 5 - 10 samples per average (we picked 8 because 2^3).
    // encoder.setAverageDepth(8);
    // encoder.setMeasurementPeriod(0);


    lowerLimitSwitch = new DigitalInput(Constants.ElevatorGrabber.lowerLimitSwitchID);

    velocityController = new PIDController(
        Constants.ElevatorGrabber.kPVoltsPerMeterPerSecond,
        Constants.ElevatorGrabber.kIVoltsPerMeter,
        Constants.ElevatorGrabber.kDVoltsPerMeterPerSecondSquared);

    feedforward = new ElevatorFeedforward(
      Constants.ElevatorGrabber.kSVolts,
      Constants.ElevatorGrabber.kGVolts,
      Constants.ElevatorGrabber.kVVoltsPer_MeterPerSecond,
      Constants.ElevatorGrabber.kAVoltsPer_MeterPerSecondSquared);

    desiredVelocity = 0;

    hasBeenHomed = false;

    timer = new Timer();
  }

  private void configureMotors() {
    elevatorMotor.restoreFactoryDefaults();
    elevatorMotor.setSmartCurrentLimit(50);
    elevatorMotor.setInverted(true);
    elevatorMotor.enableSoftLimit(SoftLimitDirection.kReverse, false);
    elevatorMotor.enableSoftLimit(SoftLimitDirection.kReverse, false);
    encoder.setPositionConversionFactor(Constants.ElevatorGrabber.grabberMetersPerRotation * Constants.ElevatorGrabber.elevatorReduction);
    encoder.setVelocityConversionFactor(Constants.ElevatorGrabber.grabberMetersPerSecondPerRPM * Constants.ElevatorGrabber.elevatorReduction);
    elevatorMotor.burnFlash();
  }


  private boolean atLowerLimit() {
    return lowerLimitSwitch.get();
  }

  private boolean atUpperLimit() {
    // Returns true if elevator position is greater than max elevator height (1.72 meters).
    return getElevatorPositionMeters() >= 1.71;
  }

  public void setElevatorMotorVolts(double volts) {
    elevatorMotor.setVoltage(volts);
  }

  public double getElevatorVelocityMetersPerSecond() {
    return encoder.getVelocity();
  }

  /**
   * Sets velocity of the elevator
   * @param targetMetersPerSecond - Make this positive if you want to extend the elevator up.
   */
  public void setElevatorMotorMetersPerSecond(double targetMetersPerSecond, double targetMetersPerSecondSquared) {
    desiredVelocity = targetMetersPerSecond;
    
    double currentMetersPerSecond = getElevatorVelocityMetersPerSecond();

    double pidOutput = velocityController.calculate(currentMetersPerSecond, targetMetersPerSecond);
    double feedforwardOutput = feedforward.calculate(targetMetersPerSecond, targetMetersPerSecondSquared);

    double totalOutput = pidOutput + feedforwardOutput;

    // Stops elevator at limits.
    if ((atLowerLimit() && totalOutput < 0) || (atUpperLimit() && totalOutput > 0))
      totalOutput = 0;

    SmartDashboard.putNumber("elevator voltage", totalOutput);

    setElevatorMotorVolts(totalOutput);
  }

  public double getElevatorPositionMeters() {
    return encoder.getPosition();
  }

  public void zeroEncoder() {
    encoder.setPosition(0);
  }

  public boolean hasBeenHomed() {
    return hasBeenHomed;
  }

  //moves elevator to a position in meters (0 being all the way down)
  public void moveElevatorToPosition(double targetPositionMeters) {

    targetPositionMeters = MathUtil.clamp(targetPositionMeters, 0, 1.71);

    if (Math.abs(this.targetPositionMeters - targetPositionMeters) < 0.01) {
      return;
    };

    this.targetPositionMeters = targetPositionMeters;

    trapezoidProfile = new TrapezoidProfile(
      new TrapezoidProfile.Constraints(
        Constants.ElevatorGrabber.elevatorMaxVelMetersPerSecond,
        Constants.ElevatorGrabber.elevatorMaxAccelMetersPerSecondSquared
      ),
      new TrapezoidProfile.State(
        targetPositionMeters, 0.0
      ),
      new TrapezoidProfile.State(
        getElevatorPositionMeters(), getElevatorVelocityMetersPerSecond()
      )
    );

    timer.reset();
    timer.start();

    isMovingToTarget = true;

    System.out.println("New Elevator Target: " + targetPositionMeters);
  }

  private void followTrapezoidProfile() {


    //holding position if no trapezoid profile is active
    if (!isMovingToTarget) {
      setElevatorMotorMetersPerSecond(0, 0);
      return;
    }

    //end trapezoid profile if reached desired position
    if (trapezoidProfile.isFinished(timer.get()) && (Math.abs(getElevatorPositionMeters() - targetPositionMeters) <= 0.005)) {
      isMovingToTarget = false;
      return;
    }



    double curTimestamp = timer.get();
    double desiredVelocity = trapezoidProfile.calculate(curTimestamp).velocity;

    // Incorporate position feedback!
    double measuredPosition = getElevatorPositionMeters();
    double desiredPosition = trapezoidProfile.calculate(curTimestamp).position;
    double positionError = desiredPosition - measuredPosition;
    // Analagous to I term of velocity controller.
    double extraVelocityPerMeter = 8;
    desiredVelocity += positionError*extraVelocityPerMeter;

    SmartDashboard.putNumber("elevator desired velocity", desiredVelocity);

    setElevatorMotorMetersPerSecond(desiredVelocity, 0);

  }

  @Override
  public void periodic() {
    if (atLowerLimit()) {
      zeroEncoder();
      hasBeenHomed = true;
    }

    followTrapezoidProfile();

    SmartDashboard.putBoolean("is moving to target", isMovingToTarget);
    SmartDashboard.putNumber("elevator target position meters", targetPositionMeters);
    SmartDashboard.putNumber("elevator position meters", getElevatorPositionMeters());
    // SmartDashboard.putNumber("motor encoder position", elevatorMotor.getEncoder().getPosition());
    SmartDashboard.putBoolean("elevator lower", atLowerLimit());
    SmartDashboard.putBoolean("elevator upper", atUpperLimit());
    //SmartDashboard.putNumber("elevator speed meters per second", getElevatorVelocityMetersPerSecond());

    // SmartDashboard.putNumber("relative encoder position", encoder.getPosition());
    // SmartDashboard.putNumber("relative encoder velocity", encoder.getVelocity());
  }
}
